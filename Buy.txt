//+------------------------------------------------------------------+
//|                                                     Buy 1.1.2.mq4|
//|                                                             dori |
//|                                             fb.com/dori.claudino |
//+------------------------------------------------------------------+

//---Observações
/*
------Implementado:
*TraillingAlls    //Ajustar para o SteathMode (pois utiliza OrderStopLoss())
*OrderAdjust      //Altera os SL e TP, vai atualizar conforme o preço médio mudar, com novas negociações etc..
*RemoveTPSL       //Remove todos os StopLoss, quando o usuário decide utilizar SteahMode(TP/SL no cliente) e não estava utilizando
*SetTPSL          //Seta todos os TakeProfits e StopLoss quando sair do modo SteathMode
*/

/*
Criar regras para contas PAMM e o usuário queira TP/SL no servidor (Contas PAMM são criadas sem SL/TP e precisam ser modificadas depois que já tiver o ticket)
Criar lógica (talves utilizar o TraillinAll) para o SteahtMode com TraillingProfit (Stops deverão ser atualizados sem OrderStopLoss() e OrderTakeProfit(), pois ambas serão 0)
Criar regra para o traillingAll com o OrderAdjust (pois se usar os dois métodos simultaneamente, um vai ajustar e o outro fazer o trailling)
Criar regra de 
*/

/*
Testar novas implementações e possiveis erros de stoploss
Testado funcoes do Buying.mq4 funções com final.Buy e estão funcionando (ao menos pra TP estão)
*/



#property copyright "dori"
#property link      "fb.com/dori.claudino"

extern double LoteInicial = 0.01;
extern double LoteExponencial = 1.5;
extern double MinLoteStep = 0.01;
extern double MaxVolume = 50;
extern int    MaxDeals = 50;
extern double MinPipStep = 50;
extern double MaxPipStep = 150;
extern double PipStepExponencial = 1.5;
extern double TakeProfit = 100;
extern double StopLoss   = 60;
extern int    MagicNumber = 1802;
extern int    Slippage = 3;
extern bool   UseTraillingProfit = true;
extern double TrailStart = 80;
extern double TrailStop = 30;
extern bool   MoneyManagement = false;
extern double RiskRatio = 0.3;


double maior = 0;
//+------------------------------------------------------------------+
//| expert initialization function                                   |
//+------------------------------------------------------------------+
int init()
  {
   if(LoteInicial<MarketInfo(Symbol(),MODE_MINLOT))LoteInicial = MarketInfo(Symbol(),MODE_MINLOT);
   if(MinLoteStep<MarketInfo(Symbol(),MODE_LOTSTEP))MinLoteStep = MarketInfo(Symbol(),MODE_LOTSTEP);
   if(MarketInfo(Symbol(),MODE_DIGITS)==3 || MarketInfo(Symbol(),MODE_DIGITS)==5){MaxPipStep*=10; MinPipStep*=10;TakeProfit*=10;TrailStart*=10;TrailStop*=10;StopLoss*=10;}
   return(0);
  }
//+------------------------------------------------------------------+
//| expert deinitialization function                                 |
//+------------------------------------------------------------------+
int deinit()
  {
//----
   
//----
   return(0);
  }
//+------------------------------------------------------------------+
//| expert start function                                            |
//+------------------------------------------------------------------+
int start()
  {
  
   if(UseTraillingProfit){}
   
   bool TradeNow = false;
   int total_deals = TotalDeals(OP_BUY);
   double last_open_price = FindLastOpenPrice(OP_BUY);
   double average_price = AveragePrice(OP_BUY);   
   double last_lote = GetLastLot(OP_BUY);
   double total_lote = TotalLotes(OP_BUY);
   
   //variavel para controle do trailling profit
   if(total_deals==0) maior =0;
   
   //controle do loteinicial
   if(MoneyManagement)LoteInicial=NormalizeDouble(AccountBalance()*AccountLeverage()/1000000*RiskRatio,0)*MarketInfo(Symbol(),MODE_MINLOT);
   
   //volume com potencial 
   double CustomVolume = NormalizeDouble(LoteInicial*MathPow(LoteExponencial,total_deals),2);   
   
   //pipstep com potencial
   double CustomPipStep = NormalizeDouble(MinPipStep*MathPow(PipStepExponencial,total_deals-1),2); //aqui foi utilizado -1, para nao sair multiplicando logo na segunda negociacao *bug do ilan*
  
   if(ObjectDelete("MP"))
      ObjectCreate("MP",OBJ_HLINE,0,Time[0],average_price);
   else
      ObjectCreate("MP",OBJ_HLINE,0,Time[0],average_price);       
      
   //Com maxpipstep o preco ira atualizar, evitando esperar grande volatilidade
   if(CustomPipStep>MaxPipStep) CustomPipStep = MaxPipStep;
  
   //CustomVolume é menor que o permitido
   if(CustomVolume>MarketInfo(Symbol(),MODE_MAXLOT))CustomVolume=MarketInfo(Symbol(),MODE_MAXLOT); 
   
   //Verifica se o lotestep está sendo cumprido.
   if(CustomVolume<last_lote+MinLoteStep)CustomVolume = last_lote+MinLoteStep;  
   
   if(total_lote+CustomVolume<=MaxVolume && total_deals < MaxDeals && last_open_price-Ask>=CustomPipStep*Point)
      TradeNow = true;
   else if(total_deals<MaxDeals && total_deals ==0 && CustomVolume<=MaxVolume)
      TradeNow = true;
   else
      TradeNow = false;      
      
   if(TradeNow) SendOrder(OP_BUY,CustomVolume);   
      
   if(Bid-average_price>=TakeProfit*Point && average_price>0)
     EndSession(OP_BUY);
  
   if(TrailStart>0 && Bid-average_price>TrailStart*Point) { 
     double atual = Bid;
     if(atual>maior)maior=atual;
     if(maior-atual>TrailStop*Point) EndSession(OP_BUY);
   }      
 
   
  
   Sleep(300);
   Comment("Deals:"+total_deals+"\nLotes:"+DoubleToStr(total_lote,2)+"\nAveragePrice:"+DoubleToStr(average_price,Digits)+"\nNext Volume:"+DoubleToStr(CustomVolume,2)+"\nWait:"+DoubleToStr(CustomPipStep-((last_open_price-Bid)/Point),0)+"(in pips)");
   Sleep(500);
   
  
   return(0);//
  }
//+------------------------------------------------------------------


//Passe o tipo OP_BUY ou OP_SELL e volume
int SendOrder(int ordertype,double volume){
      for(int n=5;n>=0;n--){
         int ticket = OrderSend(Symbol(),ordertype,volume,Ask,Slippage,0,0,"",MagicNumber,NULL,NULL);      
         int err = GetLastError();
         if (err == 0/* NO_ERROR */) break;
         if (!(err == 4/* SERVER_BUSY */ || err == 137/* BROKER_BUSY */ || err == 146/* TRADE_CONTEXT_BUSY */ || err == 136/* OFF_QUOTES */)) break;
         Sleep(5000);
      }
   return(ticket);   
}

//Passe o tipo OP_BUY ou OP_SELL
//
void EndSession(int ordertype){
int n = 5; //num tentativas
   for(n = 5;n>=0;n--){   
      for (int i = OrdersTotal() - 1; i >= 0; i--) {
         if(OrderExist(i,ordertype)){
            if(!OrderClose(OrderTicket(),OrderLots(),Bid,3)){
               Sleep(1000);
               RefreshRates();
            }   
         }
      }
   }   
}

//Passe o tipo OP_BUY ou OP_SELL
//Calcula total de ordens de acordo com o tipo passado
//Faz uma média pondera: OrderOpenPrice() * OrderLots()
//Divide A média pondera acumulada, com o total de lots acumulados
//Retorna o preço médio com o peso de cada OrderOpenPrice()*OrderLots()
double AveragePrice(int ordertype){
   int total = TotalDeals(ordertype);
   double AveragePrice = 0;
   double Count = 0;
   for (int i = OrdersTotal() - 1; i >= 0; i--) {
      if(OrderExist(i,ordertype)){
         AveragePrice += OrderOpenPrice() * OrderLots();
         Count += OrderLots();
      }    
   }     
   if (total > 0) AveragePrice = NormalizeDouble(AveragePrice / Count, Digits);
   return(AveragePrice);
}


//Passe o tipo OP_BUY ou OP_SELL
//Retorna o total de negociação
int TotalDeals(int ordertype) {
   int count = 0;
   for (int i = OrdersTotal() - 1; i >= 0; i--) {
      if(OrderExist(i,ordertype))
         count++;
   }
   return (count);
}

//Passe OP_BUY ou OP_SELL
//Retorna o total de Lotes
double TotalLotes(int ordertype) {
   double lotes = 0;
   for (int i = OrdersTotal() - 1; i >= 0; i--) {
      if(OrderExist(i,ordertype))
         lotes+=OrderLots();
   }
   return(lotes);
}

//Passe OP_BUY ou OP_SELL
//Retorna o preço de abertura da ultima negociação aberta
double FindLastOpenPrice(int ordertype) {
   double LastOpenPrice;
   int atual;
   int maior = 0;
      for (int i = OrdersTotal() - 1; i >= 0; i--) {
         if(OrderExist(i,ordertype)){
         atual = OrderTicket();
            if (atual > maior) {
               LastOpenPrice = OrderOpenPrice();
               maior = atual;
            }
         }
      }
   return (LastOpenPrice);
}

//Passe OP_BUY ou OP_SELL
//Retorna o lote da ultima negociação aberta
double GetLastLot(int ordertype) {
   double LastLot;
   int atual;
   int maior = 0;
      for (int i = OrdersTotal() - 1; i >= 0; i--) {
         if(OrderExist(i,ordertype)){
         atual = OrderTicket();
            if (atual > maior) {
               LastLot = OrderLots();
               maior = atual;
            }
         }
      }
   return (LastLot);
}

//Passe o tipo OP_BUY ou OP_SELL
bool OrderExist(int i, int ordertype){  
   return(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) && OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && OrderType() == ordertype);  
}

//Passe o tipo OP_BUY ou OP_SELL
void RemoveTPSL(int ordertype){
   double LastLot;
   int atual;
   int maior = 0;
      for (int i = OrdersTotal() - 1; i >= 0; i--) {
         if(OrderExist(i,ordertype)){
            if(OrderTakeProfit()>0 || OrderStopLoss()>0) OrderModify( OrderTicket(), OrderTakeProfit(), 0, 0, NULL, NULL );            
         }
      }   
}

//Passe o tipo OP_BUY ou OP_SELL
void SetTPSL(int ordertype){
   double LastLot;
   int atual;
   int maior = 0;
      for (int i = OrdersTotal() - 1; i >= 0; i--) {
         if(OrderExist(i,ordertype)){
            double average = AveragePrice(OP_BUY);
            if(OrderTakeProfit()==0 || OrderStopLoss()==0) OrderModify( OrderTicket(), OrderTakeProfit(), 0, 0, NULL, NULL );           
         }
      }   
}


//Passe o tipo OP_BUY ou OP_SELL
//Varre todas as negociações, verifica qual SL e TP está fora da regra
//Altera todos os TP e SL
void OrderAdjust(int ordertype){   
bool modify = false;
   for(int i=0;i<OrdersTotal();i++){
      if(OrderExist(i, ordertype)){
         int    Ticket = OrderTicket();
         double oTakeProfit = OrderTakeProfit();
         double oStopLoss = OrderStopLoss();
         double oOpenPrice = OrderOpenPrice();
         double oNewTakeProfit = 0;
         double oNewStopLoss = 0;
         modify = false;   
         double averagePrice = AveragePrice(OP_BUY);   

            switch(OrderType()){
               case 0://buy
                  if(oTakeProfit != averagePrice + oTakeProfit*Point){
                     modify = true;    
                     oNewTakeProfit = averagePrice + oTakeProfit*Point;
                     oNewStopLoss = averagePrice - oStopLoss*Point;
                  }
                  if(oStopLoss != averagePrice - oStopLoss*Point){
                     modify = true;    
                     oNewTakeProfit = averagePrice + oTakeProfit*Point;
                     oNewStopLoss = averagePrice - oStopLoss*Point;
                  }
               break;//exit switch   
            }////exit switch

            if(modify == false) continue; //exit cycle orderstotal

            //Verificar a necessidade de filtrar se os novos TP/SL vão gerar algum erro (caso o servidor não aceite TP/SL = 0)
            //Pode-se fazer a verificação se estão zerados e atribuir então o OrderStopLoss 
            //para SL e OrderTakeProfit para TP
            if(!OrderModify(oTakeProfit,oOpenPrice,oNewStopLoss,oNewTakeProfit,0)) continue;

      }//ordersexist
   }//orders total
}



//Trava todas posições, apertando os stops
//tStart = *Pips para começar a encurtar os stop
//tStop = *Pips que a moeda pode recuar, oscilar, caso oscile mais que isso, chegara ao stop.
//ordertype = Passe OP_BUY ou OP_SELL
//Função só poderá ser utilizada se os stop estiverem sendo enviados para o servido, caso esteja em --SteathMode não usar essa função
void TrailingAlls(int tStart, int sStop, int ordertype) {
   int profit;
   double stoptrade; //StopLoss atual da ordem
   double stopcal;   //proximo Stoploss
   double AvgPrice = AveragePrice(OP_BUY);
   if (sStop != 0) {
      for(int i=0;i<OrdersTotal();i++){
         if(OrderExist(i, ordertype)){
             switch(OrderType()){
               case 0://buy
                  profit = NormalizeDouble((Bid - AvgPrice) / Point, 0);
                  if (profit < tStart) continue; //profir ainda não alcançou o valor minimo para começar a fazer os traillings.
                  stoptrade = OrderStopLoss();
                  stopcal = Bid - sStop * Point;

                  //OP_BUY a ideia aqui é jogar os stoploss sempre pra cima, apertando e forçando a dar mais lucro.
                  if (stoptrade == 0.0 || (stoptrade != 0.0 && stopcal > stoptrade)) OrderModify(OrderTicket(), AvgPrice, stopcal, OrderTakeProfit(), 0, Aqua);
                  Sleep(1000);
               break;
            }
         }
      }
   }
}





/* Funcoes abaixo estão funcionando perfeitamente, verificar o magicnumber
/*************** OrderModify **************/
int OrderModify.Buy(){   
bool modify = false;
   for(int i=0;i<OrdersTotal();i++){
      if(OrderSelect(i,SELECT_BY_POS)==true){
      if(OrderSymbol() != Symbol() || OrderType() != OP_BUY) continue;
      int    TK = OrderTicket();
      double TP = OrderTakeProfit();
      double SL = OrderStopLoss();
      double OP = OrderOpenPrice();
      double newTP = 0;
         modify = false;      
         double avp =GetAveragePrice.Buy();

         switch(OrderType())
         {
            case 0://buy
               if(TP != avp+TakeProfit*Point){
                  modify = true;    
                  newTP = avp+TakeProfit*Point;        
               }   
            break;//exit switch   
         }////exit switch
         
         if(modify == false) continue; //exit cycle orderstotal

            OrderModify(TK,OP,SL,newTP,0);
            if(GetLastError()>0)continue;
            
      }//exit if orderselected
   }//exit cycle orderstotal
}

double GetAveragePrice.Buy(){
   int total = CountTrades.Buy();
   double AveragePrice = 0;
   double Count = 0;
   for (int i = OrdersTotal() - 1; i >= 0; i--) {
      OrderSelect(i, SELECT_BY_POS, MODE_TRADES);
      if (OrderSymbol() != Symbol()) continue;
      if (OrderSymbol() == Symbol()) {
         if (OrderType() == OP_BUY) {
            AveragePrice += OrderOpenPrice() * OrderLots();
            Count += OrderLots();
         }
      }
   }   
   if (total > 0) AveragePrice = NormalizeDouble(AveragePrice / Count, Digits);
   return(AveragePrice);
}

/*Funcoes*/
int CountTrades.Buy() {
   int count = 0;
   for (int trade = OrdersTotal() - 1; trade >= 0; trade--) {
      OrderSelect(trade, SELECT_BY_POS, MODE_TRADES);
      if (OrderSymbol() != Symbol()) continue;
      if (OrderSymbol() == Symbol())
         if (OrderType() == OP_BUY) count++;
   }
   return (count);
}