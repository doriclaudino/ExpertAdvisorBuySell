//+------------------------------------------------------------------+
//|                                                     Buy 1.1.4.mq4|
//|                                                             dori |
//|                                             fb.com/dori.claudino |
//+------------------------------------------------------------------+

//---Observações

#property copyright "dori"
#property link      "fb.com/dori.claudino"

extern double LoteInicial = 0.01;
extern double LoteExponencial = 1.5;
extern double MinLoteStep = 0.01;
extern double MaxVolume = 50;
extern int    MaxDeals = 50; // 0=ok 1=nok
extern double MinPipStep = 50;
extern double MaxPipStep = 150;
extern double PipStepExponencial = 1.5;
extern double TakeProfit = 100;
extern double StopLoss   = 60;
extern int    MagicNumber = 1802;
extern int    Slippage = 3;
extern bool   UseTraillingProfit = true;
extern double TrailStart = 80;
extern double TrailStop = 30;
extern bool   MoneyManagement = false;
extern double RiskRatio = 0.3;


/*double maior = 0; */
//+------------------------------------------------------------------+
//| expert initialization function                                   |
//+------------------------------------------------------------------+
int init()
  {
   if(LoteInicial<MarketInfo(Symbol(),MODE_MINLOT))LoteInicial = MarketInfo(Symbol(),MODE_MINLOT);
   if(MinLoteStep<MarketInfo(Symbol(),MODE_LOTSTEP))MinLoteStep = MarketInfo(Symbol(),MODE_LOTSTEP);
   if(MarketInfo(Symbol(),MODE_DIGITS)==3 || MarketInfo(Symbol(),MODE_DIGITS)==5){MaxPipStep*=10; MinPipStep*=10;TakeProfit*=10;TrailStart*=10;TrailStop*=10;StopLoss*=10;}
   return(0);
  }
//+------------------------------------------------------------------+
//| expert deinitialization function                                 |
//+------------------------------------------------------------------+
int deinit()
  {
//----
   
//----
   return(0);
  }
//+------------------------------------------------------------------+
//| expert start function                                            |
//+------------------------------------------------------------------+
int start()
  {
  
   if(UseTraillingProfit){}
   
   bool TradeNow = false;
   int total_deals = GetOrdersTotal(OP_BUY,Symbol(),MagicNumber);
   double last_open_price = GetLastOpenLot(OP_BUY,Symbol(),MagicNumber);
   double average_price = GetMedianPrice(OP_BUY,Symbol(),MagicNumber);   
   double last_lote = GetLastOpenLot(OP_BUY,Symbol(),MagicNumber);
   double total_lote = GetLotsTotal(OP_BUY,Symbol(),MagicNumber);
   
   //variavel para controle do trailling profit
   /*if(total_deals==0) maior =0;*/
   
   
   
   //controle do loteinicial
   if(MoneyManagement)LoteInicial=NormalizeDouble(AccountBalance()*AccountLeverage()/1000000*RiskRatio,0)*MarketInfo(Symbol(),MODE_MINLOT);
   
   //volume com potencial 
   double CustomVolume = NormalizeDouble(LoteInicial*MathPow(LoteExponencial,total_deals),2);   
   
   //pipstep com potencial
   double CustomPipStep = NormalizeDouble(MinPipStep*MathPow(PipStepExponencial,total_deals-1),2); //aqui foi utilizado -1, para nao sair multiplicando logo na segunda negociacao *bug do ilan*
  
   if(ObjectDelete("MP"))
      ObjectCreate("MP",OBJ_HLINE,0,Time[0],average_price);
   else
      ObjectCreate("MP",OBJ_HLINE,0,Time[0],average_price);       
      
   //Com maxpipstep o preco ira atualizar, evitando esperar grande volatilidade
   if(CustomPipStep>MaxPipStep) CustomPipStep = MaxPipStep;
  
   //CustomVolume é menor que o permitido
   if(CustomVolume>MarketInfo(Symbol(),MODE_MAXLOT))CustomVolume=MarketInfo(Symbol(),MODE_MAXLOT); 
   
   //Verifica se o lotestep está sendo cumprido.
   if(CustomVolume<last_lote+MinLoteStep)CustomVolume = last_lote+MinLoteStep;  
   
   
   if(total_lote+CustomVolume<=MaxVolume && total_deals < MaxDeals && last_open_price-Ask>=CustomPipStep*Point)
      TradeNow = true;
   else if(total_deals<MaxDeals && total_deals ==0 && CustomVolume<=MaxVolume)
      TradeNow = true;
   else
      TradeNow = false;      
      
   if(TradeNow) SendOrder(OP_BUY,MagicNumber,Symbol(),CustomVolume,"no commet");   
      
   /*if(Bid-average_price>=TakeProfit*Point && average_price>0)
     EndSession(OP_BUY);
  
   if(TrailStart>0 && Bid-average_price>TrailStart*Point) { 
     double atual = Bid;
     if(atual>maior)maior=atual;
     if(maior-atual>TrailStop*Point) EndSession(OP_BUY);
   }      
 */
   
  
   Sleep(300);
   Comment("Deals:"+total_deals+"\nLotes:"+DoubleToStr(total_lote,2)+"\nAveragePrice:"+DoubleToStr(average_price,Digits)+"\nNext Volume:"+DoubleToStr(CustomVolume,2)+"\nWait:"+DoubleToStr(CustomPipStep-((last_open_price-Bid)/Point),0)+"(in pips)");
   Sleep(500);
   
  
   return(0);//
  }
//+------------------------------------------------------------------

int GetOrdersTotal(int ordertype, int magicnumber, string symbol) {
	int count = 0;
	int index = 0;

	if(OrdersTotal()<1) {
		return (0);
	} else {
		for(index = OrdersTotal() - 1; index >= 0 ; index--) {
			if(OrderSelect(index,SELECT_BY_POS,MODE_TRADES)) {
			if(OrderSymbol() == symbol && OrderMagicNumber() == magicnumber && OrderType() == ordertype) {
					count++;
				} else {
					continue;
				}
			}
		}
	}
	return (count);
}


double GetLastOpenLot(int ordertype,int magicnumber, string symbol) {
   int total = GetOrdersTotal(ordertype,magicnumber,symbol);
   double lastlot = 0;
   int index = 0;
   int oldticket = 0;
   int newticket = 0;
   
      for (index = total - 1; index >= 0; index--) {
         if(OrderSelect(index,SELECT_BY_POS,MODE_TRADES)) {
            if (OrderSymbol() == symbol && OrderMagicNumber() == magicnumber && OrderType() == ordertype) {
               oldticket = OrderTicket();
				if (oldticket > newticket) {
					lastlot = OrderLots();
					newticket = oldticket;
				}
            }
         }
      }     
   return (lastlot);
}

double GetMedianPrice(int ordertype, int magicnumber, string symbol){
   int total = GetOrdersTotal(ordertype,magicnumber,symbol);
   double medianprice = 0;
   double count = 0;
   int index = 0;
   
	if(total<1) {
		return (0);
	} else {
		for(index = total - 1; index >= 0 ; index--) {
			if(OrderSelect(index,SELECT_BY_POS,MODE_TRADES)) {
			if(OrderSymbol() == symbol && OrderMagicNumber() == magicnumber && OrderType() == ordertype) {
					medianprice += OrderOpenPrice() * OrderLots();
					count += OrderLots();
				} else {
					continue;
				}
			}
		}
	}
	if(count>0){
		medianprice = NormalizeDouble(medianprice / count,Digits);
	}
	return (medianprice);
}


double GetLotsTotal(int ordertype,int magicnumber, string symbol) {
   int total = GetOrdersTotal(ordertype,magicnumber,symbol);
   int index = 0;
   double lotstotal = 0;
	
	if(total<1){
		return(0);
	}else{   
		for (index = total - 1; index >= 0; index--) {
			if(OrderSelect(index,SELECT_BY_POS,MODE_TRADES)) {
				if (OrderSymbol() == symbol && OrderMagicNumber() == magicnumber && OrderType() == ordertype) {
					lotstotal += OrderLots();
				}
			}
		}
	}		
   return (lotstotal);
}

int SendOrder(int ordertype, int magicnumber, string symbol, double Lot, string comment){
int ticket = 0;
      for(int n=5;n>=0;n--){
	  
		if(ordertype == OP_BUY)
			ticket = OrderSend(symbol,ordertype,Lot,Ask,Slippage,0,0,comment,magicnumber,NULL,NULL); 
		else
			ticket = OrderSend(symbol,ordertype,Lot,Bid,Slippage,0,0,comment,magicnumber,NULL,NULL); 			
		            
         int err = GetLastError();
         if (err == 0/* NO_ERROR */) break;
         if (!(err == 4/* SERVER_BUSY */ || err == 137/* BROKER_BUSY */ || err == 146/* TRADE_CONTEXT_BUSY */ || err == 136/* OFF_QUOTES */)) break;
         Sleep(5000);
      }
   return(ticket);   
}